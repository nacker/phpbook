// todo 变量,函数与作用域

/**
 * * 1. 块作用域
 * * 2. 函数作用域
 * * 3. 全局作用域(默认)
 */

// * 1. 块作用域
{
  // 代码块
  // 将变量的声明与赋值(初始化)二合一
  // 私有成员
  let a = 123;
  //   等价于以下二条:
  //   let a;
  //   a = 123;
  // 块中变量在块中可以访问到
  console.log(a);
}
// 块中成员,在块的外部不可访问/不可见
// console.log(a);

// * 2. 函数作用域
function sum(a, b) {
  // 在函数中声明一个变量
  // 私有变量
  let res = a + b;
  // 函数内部声明的成员可以内部访问
  console.log(res);
}
sum(30, 50);
// 但是在函数外部访问不到
// console.log(res);

// ? 私有成员: 在块/函数内部声明的成员, 仅限内部使用, 外部不可见

// * 3. 全局作用域

// 位于"代码块/函数"之外的空间, 叫"全局作用域"

// qq: 全局变量, 公共变量
let qq = "498668472";

// ! 全局成员(变量/函数)在代码的任何地方,都是可用的

{
  console.log(qq);
}

{
  {
    {
      console.log(qq);
    }
  }
}

function f1() {
  console.log(qq);
}
f1();

function f2() {
  return function () {
    return function () {
      console.log(qq);
    };
  };
}
// 因为函数嵌套了三层,所以调用了三次
f2()()();

//! 总结: 全局 ---> 块 / 函数,访问顺序像链条一个, 形成了一条"作用域链"

// * 要解决二个问题

// * 问题1: 在块/函数中, 访问一个不存在的成员 , 会发生什么?

{
  // 块中没有username
  //   console.log(username);
}

// 全局
let username = "猪老湿";
{
  {
    {
      console.log(username);
    }
  }
}

function f3() {
  // 没有username
  let username = "灭绝师妹";
  console.log(username);
}
f3();
/**
 * * 块和函数中, 如果存在与上一级作用域同名的成员,则当前成员会覆盖上一级同名成员
 * * 当前作用域的访问优先级 > 上一级作用域
 * * 简单记忆:  作用域中, 总是优先访问, 离它声明最近的成员
 */

// ! 总结: 作用域, 由外向内允许, 由内向外受限, 从而形成一条具有优先级的"作用域链"
// ! 作用域: 成员的可见范围
// ! 作用域链: 成员的访问顺序

// * 成员:  变量, 函数
